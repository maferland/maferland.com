---
title: 'Building this site with Claude Code: A frontend engineer's experience'
date: '2024-08-22T20:00:00.000Z'
excerpt: 'How I collaborated with Claude Code to build a modern Next.js 15 blog with TypeScript, TailwindCSS 4, and a complete design system in one session.'
tags: ['Next.js', 'Claude Code', 'TypeScript', 'TailwindCSS', 'Design Systems', 'Developer Experience']
---

> **Note:** This article was entirely generated by Claude Code as a demonstration of the collaborative development process described within. It represents an AI's perspective on our technical journey together.

## The Vision

When I decided to rebuild my personal website, I had a clear vision: a modern, performant blog built with the latest technologies, but I wanted to explore a new way of building it. Instead of coding alone, I decided to collaborate with Claude Code to see how AI could enhance my development workflow.

The goal was ambitious: build a complete blog system from scratch using Next.js 15, TypeScript, TailwindCSS 4, and create a comprehensive design system with proper component abstractions.

## The Stack

We chose cutting-edge technologies that prioritize developer experience and performance:

**Framework & Core:**

- **Next.js 15** with App Router and Turbopack for lightning-fast builds
- **TypeScript** for type safety and better developer experience
- **React Server Components** for optimal performance

**Styling & Design:**

- **TailwindCSS 4** with the new `@theme` syntax and built-in CSS variables
- **Framer Motion** for smooth animations
- **Lucide React** for consistent iconography

**Content & Tooling:**

- **MDX with next-mdx-remote** for rich blog content
- **Gray-matter** for frontmatter parsing
- **Highlight.js** for syntax highlighting
- **PostHog** for analytics

## The Development Process

### Starting with Architecture

The first decision was choosing Next.js 15 with the App Router. This gave us access to the latest React features like Server Components and the new metadata API for better SEO.

```typescript
// Clean, type-safe blog post structure
interface BlogPost {
  title: string
  date: string
  excerpt: string
  tags: string[]
  slug: string
}
```

### Building the Design System

One of the most interesting aspects was building a complete design system. We created reusable components that follow modern React patterns:

```typescript
// Example of our component abstraction
interface PostCardProps {
  post: BlogPost
  basePath: string // "/blog" or "/archive"
}

export default function PostCard({ post, basePath }: PostCardProps) {
  return (
    <Link href={`${basePath}/${post.slug}`}>
      <article className="space-y-4 p-6 rounded-lg border border-transparent hover:border-slate-200 dark:hover:border-slate-700 hover:bg-slate-50 dark:hover:bg-slate-800/50 transition-all duration-200 cursor-pointer group">
        {/* Card content */}
      </article>
    </Link>
  )
}
```

### Abstracting for Reusability

A key principle throughout the build was creating abstractions that could be reused. We built:

- **`PostList`** - Reusable layout for both blog and archive pages
- **`PostCard`** - Clickable post cards with hover animations
- **`PostMeta`** - Date and tags display component
- **`PostLayout`** - Individual post page layout
- **Utility functions** - `getPosts()` and `getPost()` for content loading

This meant that adding the archive section was trivial - just reuse the same components with different data sources.

### Content Migration

We built a TypeScript migration script to fetch and convert 11 previous blog posts from JSON format to MDX:

```typescript
async function migratePost(slug: string): Promise<boolean> {
  const post = await fetchPost(slug)
  if (!post) return false

  const mdxContent = convertToMDX(post)
  const outputPath = path.join(
    process.cwd(),
    'src/content/archive',
    `${post.slug}.mdx`
  )

  await fs.writeFile(outputPath, mdxContent, 'utf8')
  return true
}
```

The script successfully migrated all 11 posts with proper frontmatter and tags.

### Solving Technical Challenges

**MDX Server vs Client Components:**
We initially ran into issues with `next-mdx-remote/rsc` in client components. The solution was to properly separate server and client responsibilities.

**PostHog Instrumentation:**
The analytics setup required dynamic imports to prevent server-side evaluation errors:

```typescript
function initPostHog() {
  if (typeof window === 'undefined') return

  const posthogKey = process.env.NEXT_PUBLIC_POSTHOG_KEY
  if (!posthogKey) return

  // Dynamic import to avoid server-side issues
  import('posthog-js').then(posthog => {
    posthog.default.init(posthogKey, {
      api_host: '/ingest',
      ui_host: 'https://us.posthog.com',
      capture_exceptions: true,
    })
  })
}
```

## The Results

In a single development session, we built:

✅ **Complete blog system** with MDX support and syntax highlighting  
✅ **Archive section** with 11 migrated posts, properly tagged  
✅ **Reusable design system** with 5 core components  
✅ **Dark mode support** with smooth transitions  
✅ **Type-safe architecture** throughout  
✅ **Modern development tooling** with lint-staged and TypeScript

## Reflections on AI-Assisted Development

Working with Claude Code was remarkably different from traditional development:

**Speed:** Complex abstractions that would normally take hours were built in minutes.

**Quality:** The code quality was consistently high, following modern React patterns and TypeScript best practices.

**Problem-solving:** When we hit issues (like the PostHog instrumentation problem), the debugging process was collaborative and systematic.

**Learning:** I learned new patterns and approaches that I wouldn't have considered on my own.

## What's Next

The foundation is solid and extensible. Future enhancements could include:

- Search functionality for posts
- Newsletter integration
- Contact forms
- Enhanced MDX components
- Performance monitoring

The beauty of the architecture we built is that adding these features will be straightforward thanks to the component abstractions and type-safe patterns we established.

## Conclusion

This project demonstrates that AI-assisted development isn't about replacing developers - it's about augmenting our capabilities. The combination of human vision and AI execution created something better than either could have built alone.

The site you're reading this on is the result of that collaboration: modern, fast, and built with the latest technologies, all in a single focused development session.

_This post was written in the same collaborative spirit as the codebase - with Claude Code helping to structure and refine the narrative of our technical journey together._
